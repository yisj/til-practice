# 1/16 TIL :pencil:
---
## 원격 저장소 :keyboard:
코드와 버전 관리 이력을 온라인 상에 저장하여 여러 개발자가 협업하고 코드를 공유할 수 있는 저장 공간

-  브랜치
   - 커밋과 커밋이 이어지며 하나의 선을 완성하는 것
   - 커밋을 가리키는 **포인터**

- 로컬 저장소
   - 처음 커밋을 하면 기본 브랜치 master에 커밋되는 것
   - master 브랜치에 커밋이 쌓임


- 서버의 원격 저장소 (origin)
  - 처음엔 빈 상태
  - 로컬 저장소를 서버에 **처음 푸시할 때**
    - `-u origin master` 옵션 이용
    - 연결 완료이므로 이후엔 `git push`만으로 푸시 가능
---
## GitHub 이용 :computer:
#### 1. 로컬 저장소 주소에 원격 저장소 추가
- `git remote add origin (GitHub 주소)` 를 통해 가능
- 이때, 주소를 **잘못 입력**한 경우, `git remote set-url origin (변경할 원격 저장소 주소)`를 통해 주소 수정 가능
#### 2. 로컬 저장소의 자료를 원격 저장소에 스테이징하기

자료를 원격 저장소에 저장하기 위해서는 원하는 자료를 스테이징해야 함. (저장할 준비비)

- `git add .` : 현재 모든 파일을 스테이징
- `git add (파일명)` : 해당 파일만 스테이징

#### 3. 로컬 저장소의 자료를 commit하기
스테이징한 자료를 행위의 이름과 함께 commit할 수 있음.
(체크포인트 설정이라고 생각하면 됨)

- `git commit -m "first commit(행위 이름 예시)"`을 하면 현재 스테이징 된 자료들이 저장됨

#### 4. commit된 자료를 원격 저장소에 저장하기
push를 통해 로컬 저장소에 commit된 자료를 원격 저장소에 저장할 수 있음


##### - `git push -u origin master`

  - origin 서버에 master라는 이름의 브랜치를 만들면서, 로컬의 master 브랜치를 서버의 master 브랜치와 연결
  - 처음 서버에 push할 땐 **무조건** 이렇게 해야 함
  - 서버의 원격 저장소가 비어있는 경우, **한 번만** 할 수 있음
  - 나머지 팀원들은 git clone을 통해 원격 저장소를 복제하여 사용해야 함
##### - `git push` 
- 최초의 push 이후에는 `git push`만으로 commit된 자료를 push할 수 있음

> #### :question: 원격 저장소의 변경 사항을 로컬 저장소에 저장하고 싶은 경우
>`git pull`을 이용하면 원격 저장소에 있는 변경사항을 로컬 저장소에 저장할 수 있음
> (push↔pull 단어의 의미를 생각하면 더 간단)

---
#### `git revert (커밋 해시번호)`

- 특정 커밋을 무효화하는 새로운 커밋을 만듦
- 무효화 되었지만 이전 커밋은 그대로 남아있다.
- git checkout <커밋해시번호> : 이전 커밋으로 돌아가기
- ls -l: 파일 목록 확인
- 프로젝트 기록에서 commit을 없었던 일로 처리 후 그 결과를 새로운 commit으로 추가
- 해시번호는 매우 길지만 구분 가능한 정도(4글자 이상)만 입력해도 됨

#### `git checkout (커밋 해시번호)`
해당 커밋으로 돌아감

- HEAD 포인터가 해당 커밋으로 이동
- master 브랜치 포인터는 그대로
- 해당 커밋 당시의 폴더 내용이 보임
- git checkout master: 마스터의 최근 커밋으로 다시 이동


#### `git reset (옵션) (커밋 해시번호)` 
특정 commit으로 되돌아가는 작업

- **`git reset --soft (해시번호)`**
    - 작업 영역 그대로 : ls -l
    - 삭제된 것은 stage 영역에 올라가 있음 : git status
    - 커밋 기록은 삭제됨(그러나 사실 데이터베이스에는 남아있음) : git log --oneline\
- **`git reset --mixed (해시번호)`**
    - 작업 영역 그대로(삭제 x)
    - stage 영역에 없음(추적 안됨)
    - 커밋 기록이 삭제됨
- **`git reset --hard (해시번호)`**
    - 작업 영역에서도 삭제
    - stage 영역에 없음
    - 커밋 기록 삭제
> ##### :question: 커밋 해시번호란
>- `git log`를 이용하여 확인 가능
>- 해시번호는 매우 길지만 구분 가능한 정도(4글자 이상)만 입력 가능

#### `git restore (파일명)`

- 이미 커밋된 파일이 있는 경우
- 해당 파일을 수정했는데, 수정한게 마음에 안들어서, 커밋된 파일로 복원하고 싶은 경우
- 커밋에 들어있는 파일을 복사해서, 작업 영역에 있는 파일에 덮어쓰기

---
#### .gitignore 
- 추적에서 제외할 파일/폴더들의 목록
- 현재 디렉토리에는 보이지만, git에 추적되지 않으므로 향후 저장소에 저장되지 않음
- 주의사항 : 추적되고 있는 파일은 .gitignore에 추가해도 해제가 안됨
    - 명시적으로 `git rm —cached (파일명)`으로 해당 파일을 해제해야함
    - 커밋을 하지 않고 스테이지에만 추가한 상황(`git add`만 했을 때)
    : 추적만 해제가 됨
    - 커밋을 해버린 상황(`git ad` & `git commit`)에서 `git rm —cached`를 하면?
        - 기존에 저장소에 추가된 파일을 삭제하는 커밋이 새로 만들어지면서 추적 해제
        - 삭제하는 커밋은 추가로 생성되지만, 이전 커밋을 보면 기존에 커밋에 저장된 파일을 볼 수 있음

###### gitignore 생성하기

```bash
echo "문자열" > 파일명 : 해당 문자열을 내용으로 하는 파일 생성
echo "문자열" >> 파일명 : 기존 파일의 마지막 줄에 "문자열" 추가
touch .gitignore : .gitignore 파일 만들기
echo "a.txt" >> .gitignore : .gitignore 파일에 a.txt 추가
echo "a.txt" > .gitignore : .gitignore 파일 만들고 내용은 a.txt가 됨
```

##### **스테이징 영역에서 추적 제외하기**

```bash
git add b.txt : b.txt를 스테이지 영역에 추가(Git이 계속 이 파일을 추적함)
git rm --cached b.txt : b.txt를 스테이지 영역에서 삭제, 추적에서도 제외
```

##### **커밋 후 추적 제외하기**

```bash
git add c.txt
git commit -m "c.txt added" : c.txt를 커밋함(불가역적으로 기록에 남음)
git rm --cached c.txt : 추적에서 제외됨. 새로운 커밋을 하면 c.txt가 삭제되는 커밋이 만들어짐
git add . : c.txt를 삭제하고, 추적에서 제외하는 변경사항이 스테이징 영역에 올라감
git commit -m "c.txt deleted" : c.txt가 삭제되는 커밋이 만들어짐
```

결론적으로, 두 개의 커밋이 만들어짐(c.txt를 생성하는 커밋, 삭제하는 커밋).
c.txt는 삭제된 것처럼 보여도, 기록에는 남아있음.

---



